https://www.youtube.com/watch?v=7pflfBUZH98

всем добро пожаловать на
трек именно на доклад о состоянии
реактивных стримов надеюсь вы все
наслаждайтесь сегодняшним want им уже
успели что-то выучить новое на
протяжении текущего доклада вы тоже
узнаете много чего нового связанного с
реактивным программированием реактивными
стримами вообще словом реактивен мне вот
интересно как много из вас знает что
такое слово
слышали о слове реактивы понимаю что это
значит подумаете свою руку его несколько
людей супер а кто это использует вообще
он несколько людей но интересно как
много тут разных разных языковых
категорий как много тут geely став
вообще супер как много на джо скрипта
программирует а есть несколько людей я
так понимаю все остальные либо пиши нас
и в те либо пиши на питоне
либо что-то подобное да прекрасно
прекрасная аудитория суперская и давайте
тогда я с вами познакомился немного
расскажу вообще кто есть такой меня
звать олег я искренно из города киева
приехал к вам на сегодняшний день
работаю в компании найти фай где мы
полностью занимаемся реактивным
программированием реактивными стримами
мы строим open source мы строим будущее
эффективных стримов если так сказал бы и
я еще помимо этого contributor в проект
реактор это популярная библиотека для
реактивного программирования в джавит и
я собственно можно сказать не много знаю
о реактивном программирование
соответственно смогу с вами поделиться
определенное определенными вещами
инсайтами интересно не знаю ну что
давайте приступим и собственно поговорим
о том что будет на протяжении доклада
что вы могли понять что вы получите в
результате
если что могли перебежать быстренько на
соседний трек правильно давайте начнем
первую очередь мы разберемся зачем нам
нужен нужен вообще нужно реактив china
и в результате чего на возникло то есть
я хочу немного углубиться в историю так
как история привнесет понимание того как
это возникло как это развивалось и
соответственно в результате чего мы
поймем что мы в результате получили
имеет смысл соответственно уровень для
которого предназначен этот доклад
уровень аудитория
в баре начальный и intermediate помимо
этого мы узнаем что у нас есть сегодня
связанного с реактивным
программированием реактивными стримами и
в результате мы поймем и узнаем что нам
ждать в будущем годится стартуем
прекрасно на самом деле слово реактив
чины и вообще реактивное это о
взаимодействии
о реакции о состоянии самое первое
упоминание о слове реактив еще
вспоминается в 1985 году и появляется
1985 году статье связанной
статье он задевал от ментов реактив
систем в этом случае слова реактив
вспоминается вы значение в комбинации с
системой и тут появляется реактивная как
система собственно эта сеть тип систем
который реагирует на все события
непрерывно то есть continues и
это то что вспоминается в самой статье
что это значит и в принципе чем это
отличается от не реактивных систем то
есть для того чтобы прояснить что же
такое не реактивные системы тогда ну
представьте что у нас есть гусь есть
бусинка которому постоянно приходят
какие-то команды сделает то иди туда не
делает то не делай это сюда туда
соответственно не реактивная система она
обрабатывает только те ивенты которые
интересны она не реагирует и не меняет
свое состояние в зависимости от всех
событий то есть гу скал нокий ничего
делать не буду пусть говорят что угодно
в отличие от не реактивных систем в
контрастный con 6 реактивная система это
система которая абсолютно меняет свое
поведение как результат обработки
абсолютно всех событий то есть меняется
внешнее состояние приходят какие-то
дополнительные параметры и система тоже
меняется
затем понятно да то есть это вот такой
вот краткое интеравто что такое
реактивная с точки зрения системы но на
самом деле развитие реактив чины
началось не с систем а началась
пользовательского интерфейса и началась
еще в 90-х годах собственно чем так
интересный 90 годах именно в этот
промежуток времени начинается можно так
сказать война между макинтошем и windows
и собственно война за пользовательский
за пользователей в это время начинается
разработка пользовательских интерфейсов
и основная проблема с которой
сталкиваются разработчики это то что для
того чтобы построить отзыв
интерфейс необходимость использовать
соответствующие технологии
что это значит давайте посмотрим на
простенькую дамку мне симуляции которыми
я буду постоянно которым я буду
постоянно обращаться
вам хорошо видно что-то написано
читается да но собственно задача очень
простая мы хотим построить
пользовательский интерфейс мы хотим
перетягивать какой-то объект то сделать
там вот эти движущиеся японки папочки и
так далее и тому подобное соответственно
мы хотим реагировать на evanda
иван ты какие пользовательские нажатия
мыши up n down
перетягивание мыши то есть движения и
соответствие в зависимости от вот этих
всех переменных и можно сказать действий
передвигать объект вправо или влево и
и принципе за движением мыши
соответственно если мы будем
использовать старые подходы а старый
подход это вот например просто пулить
данные пулить периодически проверять то
есть у нас тут есть какая-то у нас есть
тут какая-то even feel в которую мы
складируем данные каким-то образом то
есть мы на это не не влияем мы собираем
информацию и периодически проверяем а
что туда пришло и перестраивать
состоянии простая задача да все очевидно
соответственно давайте запустим
посмотрим как это будет выглядеть
то есть вот наш объект соответственно
если мы будем использовать такой подход
наш ей будет приблизительно выглядеть
вот так вот видим все тормозит абсолютно
не юзер френдли и никакой пользователь
не будет доволен таким говорят такой
скоростью рендеринга понятное дело что
это все можно конфигурировать можно
менять скорость переговори рендеринга
страниц она тут заключается вопрос а
стоит ли вы просто будем в тупую жечь
цепью и это будет абсолютно
неэффективное использование ресурс
соответственно проблема ясно потому
давайте двигаться дальше собственно
проблема осознали еще в 90-х годах и в
1992 году винду говорят microsoft
публикует статью о том что в windows
вышла новая programming они предлагают
maven новую programming experience
собственно то что они предлагают это
новый ивент ривен и 5 как они называют и
вся идея заключается в том что у них
появился говоря возможность
слушайте ванты то есть установить
какую-то функцию и соответственно обзоре
все нотификации которые приходят туда
собственно позже это этот подход получил
название уже в 1995 поттер наблюдатель и
собственно давайте посмотрим как же
поменялось поведение системы с
появлением вот такого вот подхода
открываем сразу же следующую
демонстрацию переходим к нашему push you
а.ю.
и что же у нас появляется в пушке а я
собственно вся идея это не push ей вот
наш push ей собственно все остается
точно таким же у нас есть наши
обработчики событий но теперь мы
передаем с именем объектам или
определенным системным элементом
возможность вызывать эти функции то есть
обычный callback подход прямолинейно
просто да все все все с таким
сталкивались видели похоже год
соответственно когда приходит event у
нас есть возможность моментально его
обработать соответственно поведение
системы победить поведения
пользовательского интерфейса естественно
перезагрузить смотрим до нас фауне тут
нас push файл
соответственно поведение системы
становится в разы лучше
это изменение на лицо правда супер то
есть если сделать кратенько то что мы
сделали мы установили обзор на
определенный в рынок определенный обзор
был на определенный источники мантов
который сам нам модифицирует о всех
новых событиях
соответственно мы вообще не не паримся о
том как система обрабатывает все эти все
эти и ванты и
на жест моя задача это построить
бизнес-логику в результате появления
этого ивента
все круто ну на самом деле юань стал
эволюционировать сложность интерфейсов
стала меняться помимо того что нам
просто нужно было перетягивать объекты
нам нужно было сделать более сложный
processing ивентов строить более сложные
анимации в результате открытия закрытия
окон и код который стал получаться стал
абсолютно не простым и очень стало легко
наступить на грабли а то и написать не
понятно что что-то вроде такого то есть
получалось что получалось и код
становился все хуже и хуже
то есть теперь проблематика со временем
временем эволюции стало следующий
возникла необходимость строит все
сложнее и сложнее говоря сложнее фло
обработки интерфейс этого ли
нетривиальный так как user experience
нужно было улучшать и читаемости
прозрачность кода становилось все
сложнее понятное дело решение нашлось
инета и в 1997 году все тот же microsoft
а именно канал или от который был членом
группы
графической группы research are of
microsoft парисы в полку в пальто
лайфхаках в общем с полом из
университета ель придумали следующее
решение написали white paper который
получил название function реактивный
мишин
собственно в чем заключалась идея
данного подхода идея очень простая
они предложили структуры
стандартизированы набор структур и
функций которые позволяли
упростить построение вот сложных
операций и при выборе преобразований
всех ивентов и соответственно действию
над объектами соответственно использую
общей
языковой подход или языковую парадигму
стало очень легко построить сложные
анимации такие как например упоминается
вот на слайд собственного там
заключалась основная идея functional
реактивы не мишин и можно сказать вот
это второй момент когда уже у нас
встречается слово реактив комбинации еще
из фанкшн и мы вернёмся к этому моменту
но давайте сделаем этот итог все круто
то есть you like начал развиваться у нас
появилась языковая про дима которую
простила в строении анимацией действием
над и бантами и так далее тому подобным
соответственно поттер наблюдатель стал
основным движущим паттерном для
построения я и functional реактивы не
меньшим дал качок развитию новой
языковой парадигмы для построения всех
анимаций в баре на юань казалось бы что
еще нужно но все круто но мы пола все
круто но мы плавно двигались в 2000-м
годам и собственно 2002 годах началось в
буря началась новая эра
что собственно произошло произошло то
что мы начали строить распределенные
системы
мы начали строить приложение своим
которые загружались браузер
соответственно для построения
эффективного приложения как
уже работает по сети необходимы
следующие новые более раздвинутые
в подходы что это значит давайте
посмотрим в начале девяностых все
системы были рубля
запечатаны внутри одной машины это был
один общий хотбар и делался делась
предположение что доступ к любым
ресурсам можно принять за моментальный
доступ
соответственно давайте перейдем
следующий эмуляции
соответственно никто не брал во внимание
что у нас есть сеть что у нас есть
определенная задержка при взаимодействии
и обработки want of происходило путем за
прошивания новых новой порции данных то
есть мы говорили дай нам следующий
элемент отдай нам следующий элемент
отдай нам следующий элемент то есть
самый обычный паттерн итератор и таким
образом мы строили всю обработку в
результате дополнительные в нашем в
нашем пайпе то есть это то как строил
строились приложение в начале 2000 но
возникла следующая проблема и проблема
заключалась в том что как бы помимо
вы com в распределенной системе есть
сеть и сеть естественно доступ по сети
является не моментальным соответственно
что он привносит давайте посмотрим вот у
меня есть параметр network late in se
которую изменяя соответственно он вовсе
все взаимодействие добавляет
определенную задержку то есть есть у нас
задержкой на отправку запросов есть у
нас задержка на получение результата
смотрим как у нас поменялось поведение
системы видим что все стало в разы my
длине и даже если мы ускорим скорость
воспроизведения данной анимации данной
симуляции в три раза у нас все равно
займет очень очень очень много времени
чтобы обработать вот этих 20 несчастных
элементов которые мы хотим получить из
нашего источника будь то база данных или
внешний сервис соответственно проблема
налицо и понятное дело что самое простое
решение для для данной проблемы то а
почему бы не взять все в информацию
доступны во внешнем сервисе не
переместить ее к нам собственно на наш к
нашему клиенту логично логично давайте
посмотрим как это будет соответственно
берем следующую эмуляцию в которой
собственно мы делаем следующее
отправляем запрос берем все данные
агрегируется
переносим на наш клиент и обрабатываем
на клиенте как это нам нужно понятное
дело что это занимает в разы меньше
это достаточно быстро и эффективно но
тут есть несколько нюансов
первый нюанс это то что у нас не
безграничные ресурсы и небе ограниченная
пропускная способность
и любая сеть имеет свой лимит
соответственно у нас пока что этих
лимитов не указана но мы их можем легко
изменить
что если мышцы укажем что наша
пропускная способность на
сеть это 25 элементом то есть какое-то
примерное значение соответственно что
происходит из этого мы генерируем
результат сгенерировали из результат
теперь мы весь результат к сожалению не
можем заплатить в network соответственно
мы должны слышать это все по частям то
есть мы должны отправить одну часть
обрабатывать эту часть моментально мы не
можем потому что мы должны полностью
получить все тело за групп варя ответа
и только после того как мы получили все
ответила ответы мы можем начать нашу
обработку что естественно добавляет
задержку мы это видим несколько секунд
задержки в результате вот такого вот
такой вот передачи данных
понятное дело эффективно но есть 2 лимит
помимо того что у нас есть пропускная
способность сети сети у нас не
безграничные ресурсы компьютеров у нас
нет такого возможности сделать память
нашу
оперативную и леру говоря память
статическую память или hard disk
безграничным соответственно у нас есть и
тут лимита на к примеру что если у нас
запас памяти всего лишь двадцать три
элемента что произойдёт в этом случае
вот посмотрите я добавил при появлении
памяти появился новый бокс всем видно да
вот собственно этот бокс под названием
память который показывает насколько
насколько сейчас в текущий момент наша
память загружен соответственно что
произойдет правильно произойдет out of
memory так как мы попытались загрузить в
нашу память приложение 30 элементов или
двадцать пять элементов соответственно
прошло произошло переполнение и наше
приложение просто свалилась
все очевидно следующий подход который мы
могли бы применить в данном случае это
бачан все знакомы с бочонком слышали про
бачин
я думаю все слышали это слово
соответственно данный подход заключается
в том что вместо того чтобы запрашивать
все элементы мы запрашиваем только
порции например порцию которая
помещается в нашу оперативную память мы
делаем запрос получаем ответ
обрабатываем ответ делаем новый запрос
если нам нужно обработать больше
элементов
обрабатываем это занимает какой-то
промежуток времени понятное дело что это
все зависит так как тут есть рандомная
функция которая определяет возьмем мы
элемент отфильтруем и валиев говоря нет
фильтруем соответственно в зависимости
от перед количество перезагрузок у нас
все может измениться и мы можем сделать
несколько ходок можем сделать одну две и
три
и соответственно время обработки будет
меняться ну к примеру вот мы потратили 4
14 секунд на обработку всего патча
понятное дело что это эффективнее
это надежнее по использованию памяти но
не совсем хорошо возвращаемся к нашим
слайдам и собственно что происходило в
это было начало двухтысячных годов все
тот же мат microsoft все не брались
microsoft начал анализировать недостатки
всех этих подходов собственное объясню
немного позже почему основные проблемы
данного подхода заключались в том что
фотки по одному элементу стали
неэффективны потому что у нас появилась
сеть появилась ли tense
пропускная способность естественно сети
не безгранична и ресурсы компьютера не
безграничны в результате какой подход мы
не используем мы не использовали
у нас было бы не самое эффективное
использование ресурсов нашего компьютер
и у нас было бы немного более большая
задержка в результате обработки данных
соответственно в это где-то в это время
в майкрософте в глубинках microsoft и
сидел эрик мейер со своей командой и
придумывал а как же решить эту проблему
собственно что у них происходила
помянуть того что они тратили
невероятное количество ресурсов на
разработку windows на разработку windows
они начали смотреть в сторону
распределенных систем и думать а как же
построить свой клан собственном начале
двухтысячных уже microsoft думал о своем
пожурил на самом деле и соответственно
команда три камеры и занималась этим
занималась research им в области того
как сделать эффективную обработку данных
в распределенных системах
давайте посмотрим собственно что они
придумали о придумали они очень простой
подход вместо того чтобы каждый раз
спрашивать ресурсы так как запрос
ресурсов это фотка туда естественно
получение ответа назад занимала днепру
говоря внушающий промежуток времени и
вместо того чтобы каждый раз ходить и
запрашивать ресурсы то есть пулить они
сказали а что если наш источник данных
будет пушить на матери этих убавляйте
данные собственно они перед попытались
перейти от простой пул моделек
асинхронный push модель ну и что из
этого вышло
давайте посмотрим следующую симуляцию
получила этот этот подход назвать точнее
этот подход push асинхронный push
получил название стримит и в результате
использования вот этого подхода
все поменялось на лицо все элементы по
мере их нахождения синхронно вложиться в
network соответственно у нас нету лимита
по можно сказать отпадает проблема
лимита по пропускной способности сети
так как у нас есть время поиска элемента
соответственно мы сразу его отправляем и
начинаем искать следующий элемент
пока тут доставляется у нас управляется
новые новые новые соответственно
постепенно у нас динамические пропускная
способность сети держится на одном месте
то же самое происходит с памятью и тем
временем наш получатель наш
сабскрайберами наш клиент может и
синхронно обрабатывать все эти в круг
варя все эти элементы что в принципе
занимает в разы меньше времени и получим
помогает повышает скорость 1
взаимодействия говорили о имели начало
обработки всех этих элементов
соответственно результат налицо мы видим
что это обработка занимает всего лишь
шесть секунд что в разы лучше чем
предыдущий врачи в предыдущие результаты
понятное дело что это классно но тут
есть один
одна основная проблема основная проблема
заключалась в том что обработка всех
этих асинхронных событий слушание всех
этих ивентов и пост последующей их
обработкой является достаточно непростой
проблемы собственно мы тут сталкиваемся
с той же проблемой с которой столкнулись
90-х годах приют разработки сложных
анимаций и в результате чего
если писать сложный код без
дополнительной языковой парадигмы мы
получаем кашу непонятный
call back home и вообще макаронную
фабрику в результате понятное дело что
основная проблематика данных подходов
которые использовали заключалась в том
что observer паттерн в принципе просто
синхронно пушил но не было возможности
понять где конец стрима так как у нас
кончаем ее стримы это не ю ай который
постоянно работает до тех пор пока мы
его не закроем и как отписаться от
источника данных если они нам более не
нужны свою очередь старый подход то есть
итеративный подход когда мы их каждый
элемент тянем-тянем пулим пулим не имеет
основной недостаток виде синхронного
пула но в подходе итератор ясно где
конец стрима вдобавок то есть мы можем
проверять например х знак казни кск знак
сказок и мы легко можем отписаться или
закрыть весь титраторы соответственно
таким образом сказать что все нам более
не нужные данные то что они придумали
получила в результате название реактивах
stations и основная идея реактив
extension заключалась в том что
необходимо давайте попробуем объединить
два этих подхода давайте объединим
паттерн обзор раз паттерном итератор и
собственно в результате объединения
появился rx или актив extinction
проекте в extensor как штат extension
сходили несколько основных интерфейсов
это обзор google то есть источник данных
на который можно было подписаться
то есть вот он вот она проявление
паттерна observer у нас был итератор
который превратился в асинхронный
итератор и соответственно
соединился с интерфейсом observer
который получил несколько методов таких
как он никсон р-он комплит собственно он
никс эта передача элементов он и oh
completo так обозначение конца стрима
и у нас появился subscription который
позволял при помощи метода council
отписаться от стрима искать что все я
больше не хочу получать данные
соответственно не шли мне эту информацию
с от результат чего мы получились
получили бан хиты от обоих подходов то
есть у нас появился синхронный push
стало ясно где конец и понятно как
отписаться прекрасно в добавок к этому
появилась языковая парадигма то есть
взяли все те же подходы из functional
рек тиффани мишин и добавили точно такие
же операторы которые упали
упростили обработку всех ивентов которые
приходят нам от нашего источника данных
соответственно при испортят это
появилось это
того супер популярны это портило
экспортировалась java-script это
портировал лишь джаву свифт и многие
языки и в результате все что оставалось
делать новому разработчику это выучить
одну языковую парадигму которая
использовалась точно также во всех
языках
все языковые параде мы получили
одинаковые операторами фильтр и так
далее и тому подобное соответственно
изучив этот подход а однажды можно было
бы можно использовать его во всех
языковых января во всяких за ковых
платформах что стало очень круто итог
казалось бы все круто
орикс решил проблемы взаимодействия
между посетить их рублей обработки
данных в распределенных системах
после построение сложных асинхронных
взаимодействий стала вновь достаточно
простым и очевидным при помощи снова же
языковой парадигмы и все стало казалось
бы уже круто круто но не совсем то есть
у нас снова возникла определенные
проблемы которую мы сейчас с вами
посмотрим чем заключается основная
проблема того что мы вот таких вот
такого подхода простого простой push
модели мы с вами рассмотрели только
частичный вариант отправки данных это
частичный вариант заключается в том что
время обработки каждого элемента которые
мы получаем на стороне клиента намного
быстрее чем скорость произведение
данного элемента но на самом деле в
распределенных системах все не так
стабильно и наш подписчик или наш клиент
может быть в разы не длинее чем наш
продюсер соответственно что если процесс
время обработки каждого имен или иван-то
занимает несколько раз больше времени
чем его поиск давайте посмотрим что из
этого выйдет выйдет из этого следующее
давайте замедлим скорость
воспроизведения и видим что мы очень
медленно обрабатываем и ванты а тем
временем все элементы из базы данных
складируется в нашу память в результате
чего мы получаем
out of memory снова и проблема
заключается в том что мы не можем явно
сказать а сколько элементов мы готовы
потреблять в текущий момент времени то
есть у нас нету такого и 5 нет такого
механизм это была основная проблема на
текущий момент сад
цена через некоторое время а именно в
2013 году
ряд компаний которые занимались с
реактивными реактивным программированием
строили свои реактивные библиотеки
решили объединиться для работы над
совместным стандартам который получил
название реактив стрим спецификации
собственно в чем суть актив стресс
спецификация суть добавить
дополнительный и пей стандартизировать
все подходы для реактивных стримов и
собственно что они сделали они
собственно попытались обвинить
реактив экстрасенс и те подходы которые
были наработаны эриком мейрам с патчем
то есть что позволяет нам patch патч
позволяет нам запросить запулить
определенное количество элементов и
соответственно в комбинации с реактивным
стримингом или push моделью мы получим
вот все тот же стримит то есть чтоб в
результате получилось получилось реактив
стрим спецификация которой были
стандартизированы четыре основных
интерфейса появился publishers с тем же
методом субскрайб места обзор lable
появился saw scrubber у которого
появился один дополнительный метод он
субскрайб
собственно для контроля для контроля
потоком данных и появился sap скрип шим
и появился один дополнительный метод
subscription который получил название
request то есть возможность асинхронно
до запросить batch элементов можно
указать например я хочу 20 элементов я
хочу 30 элементов
зависимости от вашего запас системы то
есть это все можно на самом деле
подсчитать
соответственно баны феты налицо все
также push модель асинхронная отправка
данных плюс стабильной системы давайте
посмотрим что в результате получилось
соответствие
данный место просто стриминга мы
используем теперь реактив streams и
смотрим чтобы у нас происходит системе
снова же пошел так пошел первый запрос
собственно вот этот квадратик это уже
показываются то что мы подписались и у
нас точно таким же образом начали
производиться элемента видим они точно
так же стремятся мы начинаем медленно их
обрабатывать постепенно тают у нас
скорость обработки достаточно низкая но
так как мы знаем наши
варя наши limitation и запас ресурсов мы
сможем попросить наперед только двадцать
пять элементов или 23 элементы так как
мы знаем сколько мы можем в нашей
системе положить в память соответственно
постепенно обрабатывая обрабатывая
обрабатывать через какой то промежуток
времени мы можем сделать дополнительный
запрос
учитывая время обработки и так далее и
тому подобное и соответственно после
нового запроса пока наша система наш
клиент еще обрабатывает ресурсы
нам начнут стремится дополнительные
элементы соответственно эффективность
обработки элементов станет точно такой
же то есть мы ничего не потеряем по
сравнению с обычным стримингом с обычной
push моделью но при этом мы получим
стабильные системы и у нас не произойдет
out of memory на самом деле даже если
даже вслух в кейсе в случае с быстрым
продюсером точнее с быстрым консью миром
то есть например если мы захотим вернуть
время обработки к тому какое было ранее
у нас обработка данных будет такой же
эффективный то есть у нас асинхронно
отправляется request more request more
request more соответственно обе части
системы продолжает работать достаточно
эффективно и скорость обработки
абсолютно не уступает обычным проекте в
экстерн шанс соответственно в этом и
заключался банов и смотрели дамку и
собственно что в результате получилось
на самом деле это зародилось 2012 году и
начал эволюционировали собственно до
наших дней
что мы имеем на сегодняшний день из
реактивных стримов в первую очередь
реактивные стримы распространились на
несколько языковых про платформ вы
получили все sharpie
так как это все зародилась сишарпе
получил java скрипте получили в джаве
собственно в джаве реактивные стримы
развились наиболее явно
из библиотек которые вы получили на
сегодняшний день например для чего им
это акта streams это оригинал 2
это project реактор есть порт для java
script от того же project реактор
который получил название реактор джесс
есть реактивные стримы
для тот нетто то есть мы можем
использовать один и тот же подход один и
тот-же стандарт нескольких языковых
платформах и это продолжает развиваться
на самом деле и топ казалось бы все
круто стандарта реактивных библиотек
привнес в новое дыхание в разработку
приложений особенно это сказалось мире
java так как java не было абсолютно
никаких осин не было нормального подхода
в обработке асинхронных в обработки
событий асинхронное не блокирующие
соответственно же самое большое развитие
было видно именно тут плюс улучшился и
пять тех самых реактивах stations при
помощи push-pull модели то есть мы в
результате получили в результате реактив
стрим стандарты получили push-pull
стримим что стало в vario новым дыханием
для стабильности систем все круто но
опять жизнь боль и боль заключается в
том что все было не так просто еще 2010
вы например в том же тут нате появилась
такая парадигма как осинка вы все
слышали про sing a white
но большинство людей собственно идея
sing a weight это оставить все ту же
языковую парадигму все тот же
императивный подход не меняете подход в
обработке асинхронных событий в и
добавить
оставить в говорят уже языковую
императивные парадигму но добавить
асинхронный за счет того что добавить
мне в определенные ключевые слова
то есть когда у нас есть асинхронное
событие мы говорим о white и ожидаем
прихода все это делает за нас
внутренность языка в вырастает машины
определенного языка дат нато или
например фото лине есть аналогичные
штуки
но суть в том когда только началось
развитие казалось бы rx и реактивных
стримов один человек задал вопрос а с не
убьёт ли
обзор бобул или активно extensions
появления осинка weight и интересным
ответам разработчика официального
разработчика из microsoft было то что
когда нет мы поддерживаем реактивные
стримы
но с другой стороны мы уже начинаем
работать над новым подходом который
называется sing in ум rable
собственно вот я его выделил идея sing
in a bar tumar был заключалась в том что
это все тот же итератор но асинхронный
iterator то есть все ивенты все ожидания
элементов мы можем сказать
обвернуть при помощи осинка weight of и
получать результат асинхронно при этом
не блокировать а еще в комбинации с
определенными подходами мы можем
запрашивать элементы патчами и делать
точно так же как в реактивных стримах
казалось бы это хороший удар по
реактивному программированию и
реактивным стримом так как основная
проблема реактивных стримом заключалась
в том что мы программисты а новые
подходы новые языковые параде мы а
именно реактивные стримы требовали
пробовали изменения майнце то перед
переосмысливание того как мы пишем код
соответственно мы не хочет не хотим
зачастую менять наш программный код это
бизнес абсолютно не радует
соответственно это принесло следующий
набор проблем в сложности фон сложности
написания сложности изучения данных
библиотек и новой парадигмы и казалось
бы все что нам нужно это использование а
singh & away the
этого нам хватит для построения новых
дестве распределенных и асинхронных
систем что самое
сна и связанное с этим что осинка вид
появился в котле не это имеет она имеет
suspend и как-то там еще другой рубля
именование но идея все то же самое
осинка weight по полу java-script
несмотря на то что java script был
синхронным были promise которые
позволяли обрабатывать и внт синхронно
тем не менее не добавили осинка выйти
туда и сам и самое главное это было все
sharpie
если они ошибаюсь осинка white
поддерживают еще несколько языковых пар
один но тем не менее это могло это
сделала определенный удар так как
пользователям не требовалось переходить
на новую варин на новый язык реактивный
язык реактивных стримов что самое
интересное на текущий момент дэвид тоже
развивается поддержка sing a weight
возможно некоторые из вас уже слышали об
project loon
и собственно идея project loon добавить
зеленые thread'ы или зеленые потоки в
java идея которых заключается в том
чтобы упростить обработку работу с
асинхронным программирование мне
блокирующими вызовами и не требовать
снова перехода на новый подход что самое
важное естественно кажется что нас ждет
будет ли будущее у реактивных стримов
после всего этого
ответ простой на самом деле нужно
подумать о том куда наши технологии
движутся на сегодняшний день
как много из вас слышали про грааль вам
несколько человек основная идея игра
давайте кратко раскрутка выигрывать
крыльям основная идея граалем
заключается в том чтобы запускать
во-первых привет предоставить
возможность предоставить возможность
писать это групп were компилятор
написаны на джаве автора идейность
кальвин заключается в том чтобы
запускать другие языки и такие как руби
такие как python такие как java script
на все том же г н собственно основная
идея это поработить 2
поработить java и запускать другие языки
тут для того чтобы получить более
эффективную обработку данных естественно
оптимизацию в runtime и так далее и тому
подобное что нету в других языковых
подхода соответственно тут возникает
вопрос а что будет если мы попытаемся
вот таким вот образом соединить два
абсолютных вниз абсолютно не связанных
языка
ну возьмем к примеру java java script
или рубим
и казалось бы нам нужно обрабатывать
ivan t синхронно и там и там появится в
скором времени осинка weight но тут
возникает вопрос что если один метод
возвращает to sing и вам нужно
подписаться или воспользоваться этим
методом в другой другой еды системе или
в другом языке
что будет если определенный стандарт для
sing a weight джайра наверняка есть если
определенный стандарт java скрипте или
вдохните есть но я думаю они абсолютно
разные так как это не
стандартизированный библиотек и не
стандартизированный подход это просто
языковая фичи который имплементировать
на каждый для каждого языка по своему
соответственно большой вопрос а как это
все скомбинировать и как она будет
работать как только мы начнем это
соединять в одной системе собственно
ответ простой а стандарты и стандарт и
реактив string спецификации именно
является таким стандартам так как
спецификация описывается поведение и
поближе и сабскрайберов и абсолютно
четко сказано как должно происходить
взаимодействие между повлекшим и
сабскрайберов это поведение за им
помечено точно также как джов скрипте
точно так же и в джаве и вот на эти
соответственно как только мы возвращаем
реактивный стрим из java на него можно
было бы точно также подписаться и в java
скрипте собственно давайте посмотрим на
простую демонстрацию того что я говорю
чтобы убедить вас что это абсолютно не
сказка возможно что у меня есть давайте
посмотрим у меня есть простой
java-приложения собственно я его сейчас
открою и
это java приложение это простой простой
java в баре все что я имеет тут это
актив стрим спецификация project реактор
и ничего более
у меня есть один сервис в котором есть
метод тест на сад какой-то наивное
какой-то наивный метод который
возвращает стрим элементов просто для
теста соответственно что я хочу я хочу
собрать этот вариант applied приложение
в определенный jar ник то есть я хочу
например воспользоваться определенными
свечами java я хочу распараллелить
обработку ивентов возможно я хочу что-то
еще дополнительно и сделать и получить
доступ именно к team обработку брикетик
к этому функционал и java скрипта на
самом деле уже мне сколько комп
на сегодняшний день насколько я помню
викс например начал смотреть в эту
сторону так как они разрабатывают
несколько говоря я тёр свои системы на
разных языковых платформах то есть для
них очень важно соединить это все в кучу
соответственно что мы делаем в нашем
эксперименте мы используем грааль мы
используем грааль джесс и пей и все что
мы хотим сделать мы хотим получить
доступ к нашему сервису мы хотим создать
instance этого сервиса начать обработку
подписаться на этот стрим то есть все
что мы делаем мы говорим мой сервис даст
мотив естественно мы хотим продолжить
обработку всех вот этих i want of java
скрипте как думаете это возможно
заработает ли давайте проверим
собственно вот у меня консольное
приложение давайте немного увеличу
сделаю clear и что я сейчас сделаю у
меня собрано локально сборка грааль
джесс я добавляю в класс пас
определенные несколько библиотек это
project реактор собственно это реактив
стрим спецификации и вот в самом конце я
добавляю сюда наш собранный jorney chic
то есть наше тестовое приложение в
котором есть мой сервис
я говорю запусти это все делаю из-под
ноды то есть симулируй ноду играли
обязательно надо указать что это
все-таки джиллиан varmint и собственно
вот я запускаю наш индекс granger
который я скомпилировал уже
предварительно простой доски так как тут
я использую typescript соответственно
как только я это запущу я смогу с
легкостью получить доступ к джова миру и
обработать n элементов из java скрипта
воля к примеру чтобы убедить вас что это
не фейк
я быстренько могут поменять и добавить
несколько операторов к примеру давайте
возьмем фильтр
или тейк оператор тейк и мы из нашего
стрима возьмем который сгенерируется
джайю возьмем только пять элементов
можем можем давайте пересоберём
наше приложение и собираем перри собрали
перезапускаем и смотрим вуаля java
скрипте я только получил насколько
указал эти элементов я получил пять
элементов во время у меня отправился
console сигнал на самом деле из-за того
что все синхронно
я вижу тут есть определенные баффи тем
не менее в java скрипте и увидел всего
лишь пять элементов ok давайте двигаться
дальше и что мы можем сделать из этого
а что если что мы помимо какой вывод мы
можем сделать помимо того что это можно
запускать внутри одного приложения или
внутри одного процесса который позволяет
объединить несколько несколько языковых
пар 1 давайте пойдем немного дальше а
что если мы сделаем протокол который
тоже абсолютно совместим с реактивными
стримами или даже можно или можно даже
сказать абсолютно ип лимитирует весь
функционал реактивных стримов только на
бинарном уровне напротив уровне
протокола
сетевого протокола на самом деле такой
такой эксперимент сделали в 2015 году вы
не отвлекать его внуть в глубинках
netflix и началась разработка реактивным
streams протокол на твой протоколом для
собственного интернет это в результате
данное решение данные open source
решение получило название are safe
собственно в чем идея орсотен это идея
заключается в том чтобы создать реактив
streams спецификацию как протокол и дать
возможность работать по тому же
стандарту по тому же протоколу но
абсолютно всех языковых поэтов о
платформах и естественно построить
взаимодействие в распределенной системе
и собственно это произошло и у нас есть
возможность использовать реактивные
стримы не только на одной платформе не
только внутрь играли
но на уровне распределенной системы что
является очень круто окей давайте
подведем финальный ток того всего что я
вам рассказал первую очередь эволюция
реактивных стримов началась с данных
бездомных давим еще была в 1985 году и
основная идея была построить реактивную
систему вы это помните то есть это то
что я вспоминал вначале в результате
эволюции все это конечно затронула юань
ну это все дошло до мир энтерпрайза и
что важно сказать что в мире энтерпрайза
основная идея это построить стабильный
enterprise став построить стабильную
распределенную систему то есть построить
ту же самую реактивную систему о которой
мы вспоминали и для именно для этого
подхода мы можем легко использовать
реактивный в реактивный стандарт или
стандарт реактивных стримов
стандартный стандарт это очень важно
соответственно он мы знаем что стандарт
гарантирует работу одного и того родные
ты уже библиотеки имплементировать
поэтому по этому стандарту что java
скрипте что чтоб jagwire что в мире дат
на то соответственно мы с лёгкостью
можем соединить несколько paradigm и
получить работающую систему стабильно
работающую систему который реагирует
эффективно на все события которые
происходят во внешней во внешней среде
естественно какой ответ результат в
результате данного доклада мы можем дать
что да как бы на самом деле разве в
развитии технологий происходит в
нескольких направлениях но у реактивных
стримов как у стандартов будущее есть
это будущее есть как за самой
спецификацией которую мы можем легко
объединить то есть нескольких языковых
платформах под грилем либо при помощи
над вор протокол собственно на этом все
большое спасибо за ваше внимание
если у вас есть какие-либо вопросы я вас
приглашаю их задать спасибо друзья
огромное спасибо супер
мы даже имеем пару минут даже целых пять
минут на вопросы поэтому поднимайте руку
я подбегаю конус микрофоном кому
интересно все что я запускал весь тот
исходный код который вы видели доступен
в сети то есть кому интересно может
получить и поиграться со всеми этими
вещами у себя локально на своем
компьютере запустить все те же
упражнения если у меня конечно получится
получить доступ к сети но ссылочка очень
простая
пам пам пам пам пам здравствуй
спасибо за доклад было интересно
послушать такой вопрос а вот у
презентации множество раз вы сказали что
это стандарт прям стандарты так далее я
имел разговор с менеджером там скажем
год назад два
который мне доказывал что это никакой не
стандарт и до тех пор к пока это
стандартам не будет типа ну
рассматриваете о том что мы должны идти
по этому пути мы тоже не будем это
первый вопрос на вторую часть задам
вопрос то есть вопрос заключается в том
что менеджер доказывал что у реактив
стою спецификация не является стандартом
все верно да именно вот в терминах где
это описано как что этот стандартами не
зная и из и
до 0 стандартизация должна быть
подтверждена как
допру клинками я я понял вопрос на самом
деле это стандарт принятый в мире open
source он не стандартизированный вот на
таком уровне то есть это первое но на
самом деле это стандарт настолько имеет
настолько вы хорошее значение что
например вошел если говорить о мире
живем он вошел в поддержку говоря был
как спецификация в мир java то есть
начиная с дтк 9 мы имеем реактив стрим
спецификацию внутри стандартной
библиотеки java
то есть это один такой один такой пример
того что это все-таки стандарт с другой
стороны на текущий момент я упоминал
библиотеку are so get
это как протокол это как стандарт
взаимодействия посети нас на текущий
момент мы работаем я работаю в компании
которые занимаются разработкой данного
протокол
соответственно на текущего менара делаем
все возможное чтобы это стало стандартом
в отрица это стало стандартом на уровне
на таком же уровне какой еще т.п.
спасибо по поводу второй части вопроса
вы в общем то презентацию назвали как
текущий средств по состоянию реактив
string спецификации так понимаю но в
общем то уж мне осталось непонятно так
вы верите в будущее именно того что
реализуют rx java к примеру или реактор
то есть у каждого из этих подходов там
собственные пиа и которые нужно изучать
вот эти вот набор функций которые тоже
как бы там на самом деле хороший вопрос
о котором я забыл упомянуть
основная идея разработки была идея
разработки реактив streams
спецификация заключалась в том что эта
спецификация которая должна объединить
все библиотеки
соответственно например их java 2
имплементировать этот этот этот
интерфейс project реактор не
комментирует данный интерфейс
соответственно объединить две библиотеки
и построить интер об уровне джиллиан или
на при на уровне java script очень легко
конечно же есть различие с точки зрения
и пиа и например их java 2 предоставляет
меньше функционала чем project реактор
но с моей точки зрения общее поведение
системы у них одинаковое общая помимо
респиратора понятно нам просто в том же
там кот ли не они упирают на то что не
потребуется человеку который там привык
к написанию там стандартными
императивного к
изучать новый opel а им потребуется
только там добавлять осинка weight
ну с suspend там точнее до в project
илум я думаю будет та же самая история
просто нет и на уровень джедики выносит
чего не могут котлин сделали они минут
просто там байт-код меняют просто смысл
в том что сейчас такая история что вот
эти вот библиотеки реакторы rex java
их изучение возможно не потребуется там
через год все в java добавят час этот
loom
на самом деле хорошо будет вопрос
заключается в том снова же если этого
будущее и не убьет leasing a weight как
я уже упоминал осинка weight снова же он
требует меньше ресурсов для изучения и
основная проблема с реактивной парадигма
это то что нужно поменять моей цвет
нужно понимать что это все происходит
асинхронно это новый функциональный
снова же подход соответственно это
приносит больше сложностей для изучения
для разработки с текущим подходами очень
легко выстрелить себе в ногу
но тем ни менее снова же я акцентирую
внимание что это стандарте вот например
я показал демонстрацию как при помощи
стандарта можно соединить абсолютно 2
не не не связанных друг с другом мира
соответственно с моей точки зрения
будущей есть понятное дело что где это
возможно нужно использовать более
простые подходы
но когда это касается взаимодействия
распределенные системы когда нам нужно
например соединить систему java скрипта
или джавы мы не хотим писать
дополнительные адаптеры мы не хотим
проверять надежность грааля стоило бы
воспользоваться снова же спецификации
каким-то стандартам снова же если мы
идем дальше говорим о распределенной
системе вспоминаю о том же сокете как
имплементации реактив стрим спецификации
на уровне на отвар протокола
тот же подход позволяет нам соединить
две распределенные системы которые могут
быть запущены вообще на разных машинах и
нам не нужно придумывать новый протокол
нам не нужно париться ok мы используем
осинка white но при этом нам нужно
разрабатывать архитектуру и 5 нам нужно
подумать о как же нам нашу наши данные
отдать на вне
если мы используем реактив стресс
парадигму мы используем эту парадигму
как в этой системе как в той системе мы
знаем что и 5 этих двух систем
он одинаковый то есть если мы отправляем
стрим туда если мы хотим контролировать
поток или флакон делать flow control мы
используем вот этот метод и этот метод
работает и там и там одинаково
соответственно мы легко можем
транслировать этот и 5 без особых усилий
между несколькими системами то есть в
моем
я вижу будущее в данном подходе понятное
дело что новые технологии новые подходы
упрощают разработку в целом и ими стоит
пользоваться новым если мы хотим
построить эффективную быструю систему
особенно собственно идея разработки
реактивных extraction of microsoft и
заключалась в том что данные были
слишком большие обработка должна была
должна быть достаточно быстрой и
соответственно чтобы это получить нужно
подход использовать определенные подходы
ну и как и как эффективно их старшина
собственно зарекомендовали себя как
такой подход
