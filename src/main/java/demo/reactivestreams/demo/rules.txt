https://github.com/reactive-streams/reactive-streams-jvm

1.1     The total number of onNext´s signalled by a Publisher to a Subscriber MUST be less than or equal to the total number of elements requested by that Subscriber´s Subscription at all times.
1.2     A Publisher MAY signal fewer onNext than requested and terminate the Subscription by calling onComplete or onError.
+   1.3     onSubscribe, onNext, onError and onComplete signaled to a Subscriber MUST be signaled serially.
+   1.4     If a Publisher fails it MUST signal an onError.
+   1.5     If a Publisher terminates successfully (finite stream) it MUST signal an onComplete.
+   1.6 	If a Publisher signals either onError or onComplete on a Subscriber, that Subscriber’s Subscription MUST be considered cancelled.
-   1.7     Once a terminal state has been signaled (onError, onComplete) it is REQUIRED that no further signals occur.
1.8     If a Subscription is cancelled its Subscriber MUST eventually stop being signaled.
+   1.9     Publisher.subscribe MUST call onSubscribe on the provided Subscriber prior to any other signals to that Subscriber and MUST return normally, except when the provided Subscriber is null in which case it MUST throw a java.lang.NullPointerException to the caller, for all other situations the only legal way to signal failure (or reject the Subscriber) is by calling onError (after calling onSubscribe).
-   1.10    Publisher.subscribe MAY be called as many times as wanted but MUST be with a different Subscriber each time
+   1.11    A Publisher MAY support multiple Subscribers and decides whether each Subscription is unicast or multicast.

+   2.1     A Subscriber MUST signal demand via Subscription.request(long n) to receive onNext signals.
-   2.2     If a Subscriber suspects that its processing of signals will negatively impact its Publisher´s responsivity, it is RECOMMENDED that it asynchronously dispatches its signals.
-   2.3     Subscriber.onComplete() and Subscriber.onError(Throwable t) MUST NOT call any methods on the Subscription or the Publisher.
+   2.4     Subscriber.onComplete() and Subscriber.onError(Throwable t) MUST consider the Subscription cancelled after having received the signal.
+   2.5     A Subscriber MUST call Subscription.cancel() on the given Subscription after an onSubscribe signal if it already has an active Subscription.
+   2.6     A Subscriber MUST call Subscription.cancel() if the Subscription is no longer needed.
2.7     A Subscriber MUST ensure that all calls on its Subscription's request and cancel methods are performed serially.
2.8     A Subscriber MUST be prepared to receive one or more onNext signals after having called Subscription.cancel()
-   2.9     A Subscriber MUST be prepared to receive an onComplete signal with or without a preceding Subscription.request(long n) call.
-   2.10    A Subscriber MUST be prepared to receive an onError signal with or without a preceding Subscription.request(long n) call.
2.11    A Subscriber MUST make sure that all calls on its signal methods happen-before the processing of the respective signals. I.e. the Subscriber must take care of properly publishing the signal to its processing logic.
-   2.12    Subscriber.onSubscribe MUST be called at most once for a given Subscriber
+   2.13    Calling onSubscribe, onNext, onError or onComplete MUST return normally except when any provided parameter is null in which case it MUST throw a java.lang.NullPointerException to the caller, for all other situations the only legal way for a Subscriber to signal failure is by cancelling its Subscription.

-   3.1     Subscription.request and Subscription.cancel MUST only be called inside of its Subscriber context.
3.2     The Subscription MUST allow the Subscriber to call Subscription.request synchronously from within onNext or onSubscribe.
    3.3     Subscription.request MUST place an upper bound on possible synchronous recursion between Publisher and Subscriber.
-   3.4     Subscription.request SHOULD respect the responsivity of its caller by returning in a timely manner.
3.5    	Subscription.cancel MUST respect the responsivity of its caller by returning in a timely manner, MUST be idempotent and MUST be thread-safe.
3.6     After the Subscription is cancelled, additional Subscription.request(long n) MUST be NOPs.
3.7     After the Subscription is cancelled, additional Subscription.cancel() MUST be NOPs.
+   3.8     While the Subscription is not cancelled, Subscription.request(long n) MUST register the given number of additional elements to be produced to the respective subscriber.
+   3.9     While the Subscription is not cancelled, Subscription.request(long n) MUST signal onError with a java.lang.IllegalArgumentException if the argument is <= 0.
-   3.10    While the Subscription is not cancelled, Subscription.request(long n) MAY synchronously call onNext on this (or other) subscriber(s).
-   3.11    While the Subscription is not cancelled, Subscription.request(long n) MAY synchronously call onComplete or onError on this (or other) subscriber(s).
3.12    While the Subscription is not cancelled, Subscription.cancel() MUST request the Publisher to eventually stop signaling its Subscriber. The operation is NOT REQUIRED to affect the Subscription immediately.
-   3.13    While the Subscription is not cancelled, Subscription.cancel() MUST request the Publisher to eventually drop any references to the corresponding subscriber.
-   3.14    While the Subscription is not cancelled, calling Subscription.cancel MAY cause the Publisher, if stateful, to transition into the shut-down state if no other Subscription exists at this point [see 1.9].
-   3.15    Calling Subscription.cancel MUST return normally.
-   3.16    Calling Subscription.request MUST return normally.
3.17    A Subscription MUST support an unbounded number of calls to request and MUST support a demand up to 2^63-1 (java.lang.Long.MAX_VALUE). A demand equal or greater than 2^63-1 (java.lang.Long.MAX_VALUE) MAY be considered by the Publisher as “effectively unbounded”.
